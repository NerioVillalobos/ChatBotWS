// app.js
// Modificacion funcional- > luego de la correccion de errores de compilacion
// Modificado por: Nervill
// Fecha: 2024-01-15
// Version: 1.0.0.BETA-20240115-v0.1

// --- Inicio de Adiciones para Gemini y dotenv ---
require('dotenv').config(); // Cargar variables de entorno desde .env
const { GoogleGenerativeAI } = require("@google/generative-ai");
const fetch = require('node-fetch'); // Necesario para descargar la imagen/documento desde la URL de Baileys

// Configura tu API Key de Gemini usando la variable de entorno
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

if (!GEMINI_API_KEY) {
    console.error("ERROR: La variable de entorno GEMINI_API_KEY no est√° definida.");
    console.error("Por favor, crea un archivo .env en la ra√≠z de tu proyecto con GEMINI_API_KEY=TU_API_KEY");
    process.exit(1); // Sale de la aplicaci√≥n si no hay API Key
}

const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
console.log("Gemini API Key cargada y GoogleGenerativeAI inicializado.");
// --- Fin de Adiciones para Gemini y dotenv ---


const { createBot, createProvider, createFlow, addKeyword, EVENTS } = require('@bot-whatsapp/bot')

const QRPortalWeb = require('@bot-whatsapp/portal')
const BaileysProvider = require('@bot-whatsapp/provider/baileys')
const MockAdapter = require('@bot-whatsapp/database/mock')

/**
 * IMPORTANTE: Recuerda que los flujos se declaran de forma que los flujos "hijos"
 * (a los que se llega desde otro flujo) deben ser declarados ANTES del flujo "padre"
 * que los invoca.
 */

// Define los n√∫meros de atenci√≥n administrativa por localidad (NECESITAS REEMPLAZAR ESTOS VALORES)
const NUMERO_ADMIN_FONTANA = '5491140638555@s.whatsapp.net'; // Ejemplo: reemplazar con el n√∫mero real de WhatsApp del admin de Fontana
const NUMERO_ADMIN_IBARRETA = '5491140638555@s.whatsapp.net'; // Ejemplo: reemplazar con el n√∫mero real de WhatsApp del admin de Ibarreta

// Este es el n√∫mero al que se reenviar√°n los pagos procesados por IA.
// ¬°¬°¬°ASEG√öRATE DE QUE ESTE N√öMERO NO SEA EL MISMO DEL USUARIO QUE EST√Å INTERACTUANDO CON EL BOT!!!
// Es decir, que no sea ctx.from.
const NUMERO_ADMIN_PAGOS = '5491140638555@s.whatsapp.net'; // Aqu√≠ defines tu n√∫mero de pruebas/administrador para pagos


// ----------------------------------------------------
// FLUJOS FINALES / HOJAS DEL √ÅRBOL
// ----------------------------------------------------

// Flujo para "Llama a una persona" (general, usado tambi√©n para servicio t√©cnico)
const flowLlamarPersona = addKeyword(['llamar_persona', 'llamar', 'contacto', 'agente', 'hablar con alguien', 'otras consultas']) // A√±adimos 'otras consultas'
    .addAnswer('Perfecto! Lo derivamos con una persona de atenci√≥n para resolver sus dudas.')
    .addAnswer('Por favor haga clic en el siguiente link:', null, async (ctx, { flowDynamic }) => {
        await flowDynamic('üìû https://bit.ly/4l1iOvh'); // Aseg√∫rate de que este link sea el correcto
    })
    .addAnswer('Horario de atenci√≥n: Lunes a Viernes de 9:00 AM a 6:00 PM.', { delay: 500 })
    .addAnswer(
        '¬øHay algo m√°s en lo que pueda ayudarte?\nEscribe *MENU* para volver al inicio.', // Se hace m√°s expl√≠cito el "MENU"
        {
            delay: 1000,
            capture: true,
            idle: 120000, // Se mantiene el idle por si funciona, pero el foco es el retorno manual.
            handleIdle: async (ctx, { flowDynamic, gotoFlow }) => {
                await flowDynamic('Parece que no has respondido. Regresando al men√∫ principal. Puedes escribir *MENU* en cualquier momento.'); // Mensaje m√°s claro
                return gotoFlow(flowPrincipal); // Asegura que el flujo se redirija despu√©s del idle.
            },
        },
        async (ctx, { gotoFlow, fallBack }) => {
            // Manejo de "MENU" al inicio del callback para que siempre sea una opci√≥n.
            if (ctx.body.toUpperCase().includes('MENU')) {
                return gotoFlow(flowPrincipal);
            }
            // Si el idle no se activa, este fallback debe atrapar la inactividad o entrada no esperada.
            return fallBack('No entend√≠ tu respuesta. Si deseas explorar otras opciones, escribe *MENU* para volver al inicio.');
        },
        []
    );

// Nuevo flujo para confirmar datos de pago despu√©s del OCR
const flowConfirmarPago = addKeyword(EVENTS.ACTION)
    .addAnswer(
        async (ctx, { flowDynamic, state }) => {
            const extractedDniCuit = state.get('extractedDniCuit');
            const extractedNombre = state.get('extractedNombre');
            
            const dniCuitDisplay = extractedDniCuit === 'No encontrado' ? 'No pudimos extraerlo' : extractedDniCuit;
            const nombreDisplay = extractedNombre === 'No encontrado' ? 'No pudimos extraerlo' : extractedNombre;

            await flowDynamic([
                `Hemos detectado la siguiente informaci√≥n en tu comprobante:`,
                `*DNI/CUIT:* ${dniCuitDisplay}`,
                `*Nombre:* ${nombreDisplay}`,
                `\n¬øEs esta informaci√≥n correcta? Responde *S√ç* para confirmar o *NO* para ingresarlos manualmente.`
            ]);
        },
        {
            capture: true
        },
        async (ctx, { gotoFlow, fallBack, state, flowDynamic, provider }) => {
            console.log(`[DEBUG - flowConfirmarPago] Entrada con ctx.body: ${ctx.body}`);
            const adminTargetNumber = NUMERO_ADMIN_PAGOS;
            const messageBody = ctx.body ? ctx.body.toUpperCase().trim() : '';

            const extractedDniCuit = state.get('extractedDniCuit');
            const extractedNombre = state.get('extractedNombre');
            const originalRemoteJid = state.get('originalRemoteJid');
            const originalPushName = state.get('originalPushName');
            const originalRawBody = state.get('originalRawBody');
            const originalFileUrl = state.get('originalFileUrl');
            const originalMimeType = state.get('originalMimeType');
            const originalFileName = state.get('originalFileName'); // Asegurarse de tener el nombre del archivo

            if (messageBody.includes('MENU')) {
                await flowDynamic('De acuerdo, volviendo al men√∫ principal.');
                await state.update({
                    extractedDniCuit: undefined,
                    extractedNombre: undefined,
                    originalRemoteJid: undefined,
                    originalPushName: undefined,
                    originalRawBody: undefined,
                    originalFileUrl: undefined,
                    originalMimeType: undefined,
                    originalFileName: undefined
                });
                return gotoFlow(flowPrincipal);
            }

            if (messageBody.includes('S√ç') || messageBody.includes('SI') || messageBody.includes('CORRECTO')) {
                const finalAdminMessage = `‚úÖ [PAGO CONFIRMADO POR USUARIO - OCR]\n` +
                                           `De: ${originalPushName || 'Usuario Desconocido'} (${originalRemoteJid || 'N/A'})\n\n` +
                                           `Datos de comprobante confirmados:\n` +
                                           `DNI/CUIT: ${extractedDniCuit || 'No encontrado'}\n` +
                                           `Nombre: ${extractedNombre || 'No encontrado'}\n\n` +
                                           `Texto original adjunto: ${originalRawBody || 'N/A'}`;

                await provider.vendor.sendMessage(adminTargetNumber, { text: finalAdminMessage });
                console.log(`[INFO] Datos de pago confirmados y reenviados a ${adminTargetNumber}`);

                if (originalFileUrl && originalMimeType) {
                    try {
                        if (originalMimeType.includes('image')) {
                            await provider.vendor.sendMessage(adminTargetNumber, { image: { url: originalFileUrl }, caption: `[IMAGEN ORIGINAL ADJUNTA] De ${originalPushName || 'Usuario'} (${originalRemoteJid || 'N/A'})` });
                        } else if (originalMimeType.includes('pdf')) {
                            // Usamos originalFileName si est√° disponible, si no, un nombre gen√©rico
                            const fileNameToUse = originalFileName || 'comprobante_pago.pdf'; 
                            await provider.vendor.sendMessage(adminTargetNumber, { document: { url: originalFileUrl }, mimetype: originalMimeType, fileName: fileNameToUse, caption: `[PDF ORIGINAL ADJUNTO] De ${originalPushName || 'Usuario'} (${originalRemoteJid || 'N/A'})` });
                        } else if (originalMimeType.includes('video')) {
                             await provider.vendor.sendMessage(adminTargetNumber, { video: { url: originalFileUrl }, caption: `[VIDEO ORIGINAL ADJUNTO] De ${originalPushName || 'Usuario'} (${originalRemoteJid || 'N/A'})` });
                        }
                    } catch (e) {
                        console.error('[ERROR] Error al reenviar archivo original despu√©s de confirmaci√≥n:', e);
                        await provider.vendor.sendMessage(adminTargetNumber, { text: `[ERROR REENV√çO ARCHIVO] Fallo al reenviar archivo original de ${originalPushName || 'Usuario'} (${originalRemoteJid || 'N/A'}) despu√©s de confirmaci√≥n. Error: ${e.message}` });
                    }
                }

                await flowDynamic('¬°Gracias por confirmar! Tu informaci√≥n de pago ha sido registrada. En breve la verificaremos y actualizaremos tu estado. Puedes escribir *MENU* para explorar otras opciones o iniciar una nueva consulta.');
                
                await state.update({
                    extractedDniCuit: undefined,
                    extractedNombre: undefined,
                    originalRemoteJid: undefined, // Limpiar estos al finalizar el proceso exitosamente
                    originalPushName: undefined,
                    originalRawBody: undefined,
                    originalFileUrl: undefined,
                    originalMimeType: undefined,
                    originalFileName: undefined // Limpiar tambi√©n el nombre del archivo
                });
                return gotoFlow(flowPrincipal);

            } else if (messageBody.includes('NO') || messageBody.includes('INCORRECTO')) {
                console.log(`[INFO] Usuario rechaz√≥ OCR. Redirigiendo a flowEntradaManualPago.`);
                await state.update({ // Limpiar estado de OCR antes de ir a manual
                    extractedDniCuit: undefined,
                    extractedNombre: undefined,
                    // Mantenemos los 'originalRemoteJid', etc. para que flowEntradaManualPago sepa qui√©n es el usuario original
                });
                return gotoFlow(flowEntradaManualPago); // REDIRECCION A NUEVO FLUJO MANUAL
            } else {
                return fallBack('No entend√≠ tu respuesta. Por favor, responde *S√ç* o *NO*.');
            }
        }
    );

const flowEntradaManualPago = addKeyword(EVENTS.ACTION) // Se activa por acci√≥n interna
    .addAnswer(
        'Por favor, ingresa el DNI o CUIT y el nombre completo del titular del servicio en un solo mensaje.',
        {
            capture: true // Espera la entrada manual del usuario
        },
        async (ctx, { flowDynamic, gotoFlow, state, provider }) => {
            const adminTargetNumber = NUMERO_ADMIN_PAGOS;
            const remoteJid = await state.get('originalRemoteJid') || ctx.from; // Usamos el JID original o el actual
            const pushName = await state.get('originalPushName') || ctx.pushName;
            const manualText = ctx.body;

            console.log(`[DEBUG - flowEntradaManualPago] Recibido: "${manualText}"`);

            if (manualText.toUpperCase().includes('MENU')) {
                await flowDynamic('De acuerdo, volviendo al men√∫ principal.');
                await state.update({ manualData: undefined }); // Limpiar datos manuales si vuelve a men√∫
                return gotoFlow(flowPrincipal);
            }

            const messageForAdmin = `üìù [PAGO MANUAL - DATOS RECIBIDOS]\n` +
                                     `De: ${pushName} (${remoteJid})\n\n` +
                                     `Datos ingresados manualmente:\n${manualText}\n\n` +
                                     `Esperando "LISTO" del usuario.`;

            await provider.vendor.sendMessage(adminTargetNumber, { text: messageForAdmin });
            console.log(`[INFO] Datos manuales reenviados a ${adminTargetNumber}.`);

            // Guarda el texto manual para futuras referencias si es necesario
            await state.update({ manualData: (await state.get('manualData') || '') + '\n' + manualText });

            await flowDynamic('¬°Gracias! Hemos registrado tus datos. Ahora, por favor, escribe *LISTO* cuando hayas terminado de enviar toda la informaci√≥n (incluyendo el comprobante si no lo enviaste antes).');
            // Mantenemos el flujo activo aqu√≠, esperando el LISTO
            // No hacemos gotoFlow ni return fallBack() para permanecer en este capture.
        }
    )
    .addAnswer(
        // Este `addAnswer` con `LISTO` es crucial para finalizar el ingreso manual
        'Si ya enviaste toda la informaci√≥n, escribe *LISTO*.',
        {
            capture: true, // Captura el "LISTO"
            // Opcional: idle para volver al men√∫ si el usuario no responde
            idle: 120000, 
            handleIdle: async (ctx, { flowDynamic, gotoFlow, state }) => {
                await flowDynamic('Parece que no has respondido. Regresando al men√∫ principal. Puedes escribir *MENU* en cualquier momento.');
                await state.update({ manualData: undefined });
                // Limpiar todos los estados de contexto al volver al men√∫ principal por inactividad.
                await state.update({
                    originalRemoteJid: undefined,
                    originalPushName: undefined,
                    originalRawBody: undefined,
                    originalFileUrl: undefined,
                    originalMimeType: undefined,
                    originalFileName: undefined
                });
                return gotoFlow(flowPrincipal);
            },
        },
        async (ctx, { flowDynamic, gotoFlow, state, provider, fallBack }) => { // <--- CORRECCI√ìN: AQUI SE A√ëADE fallBack
            const messageBody = ctx.body ? ctx.body.toUpperCase().trim() : '';
            const adminTargetNumber = NUMERO_ADMIN_PAGOS;
            const remoteJid = await state.get('originalRemoteJid') || ctx.from;
            const pushName = await state.get('originalPushName') || ctx.pushName;

            if (messageBody.includes('MENU')) {
                await flowDynamic('De acuerdo, volviendo al men√∫ principal.');
                await state.update({ manualData: undefined });
                // Limpiar todos los estados de contexto al volver al men√∫ principal.
                await state.update({
                    originalRemoteJid: undefined,
                    originalPushName: undefined,
                    originalRawBody: undefined,
                    originalFileUrl: undefined,
                    originalMimeType: undefined,
                    originalFileName: undefined
                });
                return gotoFlow(flowPrincipal);
            }

            if (messageBody.includes('LISTO')) {
                const finalManualAdminMessage = `‚úÖ [PAGO MANUAL - FINALIZADO POR USUARIO]\n` +
                                                 `De: ${pushName} (${remoteJid})\n\n` +
                                                 `Datos manuales recolectados:\n${await state.get('manualData') || 'No se ingresaron datos manuales espec√≠ficos.'}`;
                
                await provider.vendor.sendMessage(adminTargetNumber, { text: finalManualAdminMessage });
                console.log(`[INFO] Proceso de pago manual finalizado por ${remoteJid}.`);

                await flowDynamic('¬°Gracias por informarnos tu pago! En breve lo verificaremos y actualizaremos tu estado. Puedes escribir *MENU* para explorar otras opciones o iniciar una nueva consulta.');
                await state.update({ manualData: undefined }); // Limpiar el estado de datos manuales
                // Limpiar todos los estados de contexto al finalizar el proceso exitosamente.
                await state.update({
                    originalRemoteJid: undefined,
                    originalPushName: undefined,
                    originalRawBody: undefined,
                    originalFileUrl: undefined,
                    originalMimeType: undefined,
                    originalFileName: undefined
                });
                return gotoFlow(flowPrincipal);
            } else {
                return fallBack('No entend√≠ tu respuesta. Por favor, escribe *LISTO* si ya terminaste de enviar tu informaci√≥n, o *MENU* para volver al inicio.');
            }
        }
    );

// Flujo para "Informar un Pago"
const flowInformarPago = addKeyword(['informar_pago', 'ya pague', 'reportar pago'])
    .addAnswer(
        'Para informar tu pago, por favor, env√≠anos una captura del comprobante de transferencia junto con el nombre y DNI o CUIT del titular del servicio. Cuando hayas enviado todo, puedes escribir *LISTO* para finalizar.',
        {
            delay: 500,
            capture: true // Este capture espera tanto media como texto inicial
        },
        async (ctx, { gotoFlow, flowDynamic, fallBack, provider, state }) => {
            console.log(`[DEBUG - flowInformarPago] ctx recibido (completo):`, JSON.stringify(ctx, null, 2));
            
            const adminTargetNumber = NUMERO_ADMIN_PAGOS;
            
            // --- CORRECCI√ìN: Detecci√≥n de media m√°s robusta usando propiedades exactas de Baileys ---
            let isMedia = false;
            let mediaTypeKey = null; // Para saber qu√© tipo de media se encontr√≥
            if (ctx.message) {
                if (ctx.message.imageMessage) {
                    isMedia = true;
                    mediaTypeKey = 'imageMessage';
                } else if (ctx.message.documentMessage) {
                    isMedia = true;
                    mediaTypeKey = 'documentMessage';
                } else if (ctx.message.videoMessage) {
                    isMedia = true;
                    mediaTypeKey = 'videoMessage';
                }
            }
            // --- FIN CORRECCI√ìN ---

            const remoteJid = ctx.from;
            const messageBody = ctx.body ? ctx.body.toUpperCase().trim() : '';
            const rawBody = ctx.body || '';

            console.log(`[DEBUG - flowInformarPago] isMedia: ${isMedia} (detected as: ${mediaTypeKey}), messageBody: "${messageBody}", rawBody: "${rawBody}"`);

            await state.update({
                originalRemoteJid: remoteJid,
                originalPushName: ctx.pushName,
                originalRawBody: rawBody, // Guardamos el body original tambi√©n aqu√≠
            });

            // Manejo de comandos especiales (MENU siempre debe ser una opci√≥n)
            if (messageBody.includes('MENU')) {
                await flowDynamic('De acuerdo, volviendo al men√∫ principal.');
                await state.update({ manualData: undefined }); 
                return gotoFlow(flowPrincipal);
            }
            
            if (messageBody.includes('LISTO')) {
                await flowDynamic('Por favor, primero env√≠a tu comprobante o los datos manualmente, luego escribe *LISTO*.');
                return fallBack(); 
            }

            // Procesamiento de media con Gemini (OCR)
            if (isMedia) {
                console.log(`[INFO] Media recibida de ${remoteJid}. Intentando procesar con Gemini.`);
                try {
                    // --- CORRECCI√ìN: Acceder a mimetype, fileUrl y fileName de forma segura ---
                    let mimeType;
                    let fileUrl;
                    let fileName; 
                    const mediaMessage = ctx.message[mediaTypeKey]; // Esto ser√° ctx.message.imageMessage, ctx.message.documentMessage, etc.

                    if (mediaMessage) {
                        mimeType = mediaMessage.mimetype;
                        fileUrl = mediaMessage.url;
                        if (mediaTypeKey === 'documentMessage') {
                            fileName = mediaMessage.fileName;
                        }
                    }
                    // --- FIN CORRECCI√ìN ---

                    console.log(`[DEBUG] Tipo de MIME detectado: ${mimeType}, URL del archivo: ${fileUrl}`);

                    if (!fileUrl || !mimeType || (!mimeType.includes('image/jpeg') && !mimeType.includes('image/png') && !mimeType.includes('application/pdf'))) {
                        await flowDynamic('Tipo de archivo no soportado para OCR. Por favor, env√≠a una imagen (JPG/PNG) o un documento PDF. Puedes escribir los datos de DNI/CUIT y nombre directamente si lo prefieres. Cuando hayas enviado todo, escribe *LISTO*.');
                        console.log(`[ERROR] Tipo de archivo no soportado para OCR: ${mimeType} de ${remoteJid}`);
                        
                        const fallbackCaption = `[FALLO IA - TIPO NO SOPORTADO] Comprobante de ${ctx.pushName || 'Usuario'} (${remoteJid}). Tipo: ${mimeType}\nTexto original: ${rawBody || 'N/A'}`;
                        
                        // Reenv√≠o del archivo original si es posible
                        if (mediaTypeKey === 'imageMessage' && ctx.message.imageMessage) {
                            await provider.vendor.sendMessage(adminTargetNumber, { image: { url: ctx.message.imageMessage.url }, caption: fallbackCaption });
                        } else if (mediaTypeKey === 'documentMessage' && ctx.message.documentMessage) {
                            await provider.vendor.sendMessage(adminTargetNumber, { document: { url: ctx.message.documentMessage.url }, mimetype: ctx.message.documentMessage.mimetype, fileName: ctx.message.documentMessage.fileName, caption: fallbackCaption });
                        } else if (mediaTypeKey === 'videoMessage' && ctx.message.videoMessage) {
                            await provider.vendor.sendMessage(adminTargetNumber, { video: { url: ctx.message.videoMessage.url }, caption: fallbackCaption });
                        } else {
                            // Si por alguna raz√≥n no se pudo reenviar como media, al menos notificar al admin
                            await provider.vendor.sendMessage(adminTargetNumber, { text: fallbackCaption + '\n[No se pudo reenviar el archivo original por error interno]' });
                        }
                        return; // Mantiene el `capture` activo para que el usuario pueda intentar de nuevo o ingresar texto
                    }
                    
                    console.log(`[INFO] Descargando archivo desde URL: ${fileUrl}`);
                    const response = await fetch(fileUrl);
                    if (!response.ok) {
                        throw new Error(`Error al descargar el archivo: ${response.status} ${response.statusText}`);
                    }
                    const arrayBuffer = await response.arrayBuffer();
                    const base64Data = Buffer.from(arrayBuffer).toString("base64");

                    const fileData = {
                        inlineData: {
                            data: base64Data,
                            mimeType: mimeType
                        },
                    };

                    const model = genAI.getGenerativeModel({ model: "gemini-pro-vision" });

                    const prompt = `Extrae el DNI (Documento Nacional de Identidad) o CUIT (C√≥digo √önico de Identificaci√≥n Tributaria) y el nombre completo del titular del comprobante/documento adjunto.
                                    Si encuentras ambos DNI y CUIT, lista ambos. Si no encuentras alguno, indica "No encontrado".
                                    Formato de salida (crucial para parsing):
                                    DNI: [valor_DNI]
                                    CUIT: [valor_CUIT]
                                    Nombre: [valor_Nombre_Completo]`;

                    console.log(`[INFO] Enviando archivo a Gemini para procesamiento OCR.`);
                    const result = await model.generateContent([prompt, fileData]);
                    const textFromGemini = result.response.text();

                    console.log(`[INFO] Respuesta de Gemini para OCR (${remoteJid}):\n${textFromGemini}`);

                    const dniMatch = textFromGemini.match(/DNI:\s*([^\n]+)/i);
                    const cuitMatch = textFromGemini.match(/CUIT:\s*([^\n]+)/i);
                    const nombreMatch = textFromGemini.match(/Nombre:\s*([^\n]+)/i);

                    let extractedDni = dniMatch && dniMatch[1] ? dniMatch[1].trim() : 'No encontrado';
                    let extractedCuit = cuitMatch && cuitMatch[1] ? cuitMatch[1].trim() : 'No encontrado';
                    let extractedNombre = nombreMatch && nombreMatch[1] ? nombreMatch[1].trim() : 'No encontrado';

                    let extractedDniCuit = 'No encontrado';
                    if (extractedDni !== 'No encontrado' && extractedCuit !== 'No encontrado') {
                        extractedDniCuit = `${extractedDni} / ${extractedCuit}`;
                    } else if (extractedDni !== 'No encontrado') {
                        extractedDniCuit = extractedDni;
                    } else if (extractedCuit !== 'No encontrado') {
                        extractedDniCuit = extractedCuit;
                    }

                    console.log(`[DEBUG] Datos extra√≠dos: DNI/CUIT: "${extractedDniCuit}", Nombre: "${extractedNombre}"`);

                    if (extractedDniCuit === 'No encontrado' && extractedNombre === 'No encontrado') {
                        await flowDynamic('No pude extraer el DNI/CUIT o el nombre del comprobante. Por favor, aseg√∫rate de que la imagen sea clara y legible. Redirigiendo para que puedas escribir los datos manualmente.');
                        console.log(`[WARN] Gemini no pudo extraer datos de ${remoteJid}. Redirigiendo a entrada manual.`);
                        const fallbackCaption = `[FALLO IA - DATOS NO EXTRA√çDOS] Comprobante de ${ctx.pushName || 'Usuario'} (${remoteJid}). AI no pudo extraer datos.\nTexto original: ${rawBody || 'N/A'}`;
                        
                        // Reenv√≠o del archivo original si es posible
                        if (mediaTypeKey === 'imageMessage' && ctx.message.imageMessage) {
                            await provider.vendor.sendMessage(adminTargetNumber, { image: { url: ctx.message.imageMessage.url }, caption: fallbackCaption });
                        } else if (mediaTypeKey === 'documentMessage' && ctx.message.documentMessage) {
                            await provider.vendor.sendMessage(adminTargetNumber, { document: { url: ctx.message.documentMessage.url }, mimetype: ctx.message.documentMessage.mimetype, fileName: ctx.message.documentMessage.fileName, caption: fallbackCaption });
                        }
                        return gotoFlow(flowEntradaManualPago); 
                    }

                    await state.update({
                        extractedDniCuit: extractedDniCuit,
                        extractedNombre: extractedNombre,
                        originalFileUrl: fileUrl,
                        originalMimeType: mimeType,
                        originalFileName: fileName // Guardamos el nombre del archivo para PDFs
                    });

                    console.log(`[INFO] Datos extra√≠dos y guardados en estado. Dirigiendo a flowConfirmarPago para ${remoteJid}`);
                    return gotoFlow(flowConfirmarPago);

                } catch (e) {
                    console.error('[ERROR] Error al procesar con Gemini o al reenviar (TRY BLOCK):', e);
                    await flowDynamic('Hubo un problema al procesar tu comprobante con IA. Por favor, intenta de nuevo con otra imagen o te redirigir√© para que puedas escribir los datos manualmente.');
                    
                    try {
                        const fallbackCaption = `[FALLO IA - REQUERIR REVISI√ìN MANUAL] Fallo al procesar comprobante de ${ctx.pushName || 'Usuario'} (${remoteJid}). Error: ${e.message}\nTexto original: ${rawBody || 'N/A'}`;
                        if (mediaTypeKey === 'imageMessage' && ctx.message.imageMessage) {
                            await provider.vendor.sendMessage(adminTargetNumber, { image: { url: ctx.message.imageMessage.url }, caption: fallbackCaption });
                        } else if (mediaTypeKey === 'documentMessage' && ctx.message.documentMessage) {
                            await provider.vendor.sendMessage(adminTargetNumber, { document: { url: ctx.message.documentMessage.url }, mimetype: ctx.message.documentMessage.mimetype, fileName: ctx.message.documentMessage.fileName, caption: fallbackCaption });
                        } else {
                            await provider.vendor.sendMessage(adminTargetNumber, { text: `[FALLO IA - SIN ARCHIVO] Fallo al procesar de ${ctx.pushName || 'Usuario'} (${remoteJid}). Error: ${e.message}\nTexto original: ${rawBody || 'N/A'}` });
                        }
                        console.log(`[WARN] Comprobante original reenviado como FALLBACK a ${adminTargetNumber} debido a error de IA.`);
                    } catch (fallbackError) {
                        console.error('[ERROR] Error al reenviar el fallback de comprobante (CATCH BLOCK):', fallbackError);
                    }
                    return gotoFlow(flowEntradaManualPago); 
                }
            }
            // Procesamiento de texto (DNI/CUIT u otra informaci√≥n) si NO es media
            else if (ctx.body && ctx.body.length > 0) {
                console.log(`[INFO] Texto recibido de ${remoteJid}. Redirigiendo para entrada manual.`);
                await flowDynamic('De acuerdo, has iniciado el proceso de ingreso manual de datos. Por favor, escribe tu DNI/CUIT y nombre completo.');
                return gotoFlow(flowEntradaManualPago);
            }
            // Fallback para entradas no v√°lidas (ni media, ni texto, ni comandos reconocidos)
            else {
                console.log(`[WARN] Entrada no reconocida de ${remoteJid}. Activando fallBack.`);
                return fallBack('No entend√≠ tu respuesta. Por favor, env√≠a una *captura o archivo* de tu comprobante, o escribe tus datos de DNI/CUIT y nombre. Cuando hayas enviado todo, escribe *LISTO*. Tambi√©n puedes escribir *MENU* para volver al inicio.');
            }
        }
    );

// Flujo para "Conocer los medios de pago"
const flowMediosPago = addKeyword(['medios_pago', 'pagos', 'como pagar', 'donde pago'])
    .addAnswer('Puedes realizar tus pagos a trav√©s de los siguientes medios:', { delay: 500 })
    .addAnswer(
        '‚Ä¢ Pago en l√≠nea: [Link al Portal de Pagos]\n' +
        '‚Ä¢ Transferencia bancaria:\n' +
        '   *VANGUARD INTERNET SRL*\n' +
        '   CUIT: 30716576376\n' +
        '   CBU: 0170304520000031123901\n' +
        '   ALIAS: VANGUARD.INTERNET\n' +
        '‚Ä¢ Pagar en el local de Fontana: *Av. San Mart√≠n 1628*\n',
        null,
        async (ctx, { flowDynamic }) => {
            await flowDynamic('Recuerda incluir tu n√∫mero de cliente en la referencia.');
        }
    )
    .addAnswer('¬øHay algo m√°s en lo que pueda ayudarte?\nEscribe *MENU* para volver al inicio.', { delay: 1000, capture: true }, async (ctx, { gotoFlow, fallBack }) => {
        if (ctx.body.toUpperCase().includes('MENU')) {
            return gotoFlow(flowPrincipal);
        }
        return fallBack('No entend√≠ tu respuesta. Si deseas explorar otras opciones, escribe *MENU* para volver al inicio.');
    });

// Flujo para "Consultar precios de los servicios"
const flowConsultarPrecios = addKeyword(['consultar_precios', 'precios', 'planes', 'costo'])
    .addAnswer('Para consultar nuestros planes y precios, visita nuestra p√°gina web: [Link a la P√°gina de Precios]')
    .addAnswer('Tambi√©n puedes contactarnos directamente al *[N√∫mero de Ventas]* para una atenci√≥n personalizada.')
    .addAnswer('¬øHay algo m√°s en lo que pueda ayudarte?\nEscribe *MENU* para volver al inicio.', { delay: 1000, capture: true }, async (ctx, { gotoFlow, fallBack }) => {
        if (ctx.body.toUpperCase().includes('MENU')) {
            return gotoFlow(flowPrincipal);
        }
        return fallBack('No entend√≠ tu respuesta. Si deseas explorar otras opciones, escribe *MENU* para volver al inicio.');
    });

// Flujo para "Otras Consultas" (Modificaci√≥n para asegurar el retorno al men√∫)
const flowOtrasConsultas = addKeyword(['otras_consultas', '4', '4Ô∏è‚É£'])
    .addAnswer('Perfecto! Lo derivamos con una persona de atenci√≥n para resolver sus dudas.', null, async (ctx, { flowDynamic }) => {
        await flowDynamic('Por favor haga clic en el siguiente link: üìû https://bit.ly/4l1iOvh');
    })
    .addAnswer(
        '¬øHay algo m√°s en lo que pueda ayudarte?\nEscribe *MENU* para volver al inicio.',
        {
            delay: 1000,
            capture: true,
            idle: 120000,
            handleIdle: async (ctx, { flowDynamic, gotoFlow }) => {
                await flowDynamic('Parece que no has respondido. Regresando al men√∫ principal. Puedes escribir *MENU* en cualquier momento.');
                return gotoFlow(flowPrincipal);
            },
        },
        async (ctx, { gotoFlow, fallBack }) => {
            if (ctx.body.toUpperCase().includes('MENU')) {
                return gotoFlow(flowPrincipal);
            }
            return fallBack('No entend√≠ tu respuesta. Si deseas explorar otras opciones, escribe *MENU* para volver al inicio.');
        }
    );

// ----------------------------------------------------
// FLUJOS INTERMEDIOS
// ----------------------------------------------------

// Flujo para "Servicio T√©cnico"
const flowServicioTecnico = addKeyword(['tecnico', 'problema', 'no tengo internet', 'soporte'])
    .addAnswer('¬°Importante! Antes de continuar, por favor, realiza estos pasos:')
    .addAnswer('‚Ä¢ Reinicia tu router o equipo.\n‚Ä¢ Verifica los cables y la alimentaci√≥n el√©ctrica.\n‚Ä¢ Confirma que realizaste estos pasos.', { delay: 1000 })
    .addAnswer('¬øYa realizaste estos pasos? (S√≠/No)', { capture: true }, async (ctx, { gotoFlow, fallBack }) => {
        if (ctx.body.toUpperCase().includes('MENU')) {
            return gotoFlow(flowPrincipal);
        }

        if (ctx.body.toLowerCase().includes('si') || ctx.body.toLowerCase().includes('s√≠')) {
            return gotoFlow(flowLlamarPersona);
        } else if (ctx.body.toLowerCase().includes('no')) {
            return fallBack('Es fundamental que realices estos pasos para poder diagnosticar tu problema. Por favor, intenta de nuevo cuando los hayas completado. Si a√∫n as√≠ no puedes, podemos conectarte con un agente. Escribe *MENU* para volver al inicio.');
        } else {
            return fallBack('No entend√≠ tu respuesta. Por favor, responde "S√≠" o "No". Escribe *MENU* para volver al inicio.');
        }
    });

// Flujo para "Atenci√≥n Administrativa"
const flowAtencionAdministrativa = addKeyword(['administrativa', 'factura', 'pagos', 'planes', 'administracion'])
    .addAnswer('¬øEn qu√© puedo ayudarte con Atenci√≥n Administrativa?', { delay: 500 })
    .addAnswer('1Ô∏è‚É£ Informar un Pago\n2Ô∏è‚É£ Conocer Medios de Pago\n3Ô∏è‚É£ Consultar Precios de los Servicios\n4Ô∏è‚É£ Otras Consultas', { capture: true }, async (ctx, { gotoFlow, fallBack }) => {
        if (ctx.body.toUpperCase().includes('MENU')) {
            return gotoFlow(flowPrincipal);
        }

        if (ctx.body.includes('1') || ctx.body.toLowerCase().includes('informar') || ctx.body.includes('1Ô∏è‚É£')) {
            return gotoFlow(flowInformarPago);
        }
        if (ctx.body.includes('2') || ctx.body.toLowerCase().includes('medios') || ctx.body.includes('2Ô∏è‚É£')) {
            return gotoFlow(flowMediosPago);
        }
        if (ctx.body.includes('3') || ctx.body.toLowerCase().includes('precios') || ctx.body.toLowerCase().includes('planes') || ctx.body.includes('3Ô∏è‚É£')) {
            return gotoFlow(flowConsultarPrecios);
        }
        if (ctx.body.includes('4') || ctx.body.toLowerCase().includes('otras') || ctx.body.includes('4Ô∏è‚É£')) {
            return gotoFlow(flowOtrasConsultas);
        }
        return fallBack('No entend√≠ tu respuesta. Por favor, elige una opci√≥n v√°lida (1, 2, 3 o 4, o los emojis 1Ô∏è‚É£, 2Ô∏è‚É£, 3Ô∏è‚É£, 4Ô∏è‚É£). Escribe *MENU* para volver al inicio.');
    });

// Flujo para "Otra Zona" (Zona no cubierta)
const flowOtraZona = addKeyword(['otra_zona', 'otro', 'otra', 'mi zona no esta'])
    .addAnswer('Actualmente, nuestros servicios de internet se concentran en Fontana e Ibarreta.')
    .addAnswer('Por favor, cont√°ctanos directamente si deseas consultar la disponibilidad en otra zona: *[N√∫mero de Contacto para Otras Zonas]*')
    .addAnswer('¬øHay algo m√°s en lo que pueda ayudarte?\nEscribe *MENU* para volver al inicio.', { delay: 1000, capture: true }, async (ctx, { gotoFlow, fallBack }) => {
        if (ctx.body.toUpperCase().includes('MENU')) {
            return gotoFlow(flowPrincipal);
        }
        return fallBack('No entend√≠ tu respuesta. Si deseas explorar otras opciones, escribe *MENU* para volver al inicio.');
    });

// Flujo para "Servicio de Internet en Ibarreta"
const flowServicioIbarra = addKeyword(['Ibarreta', '2', '2Ô∏è‚É£'])
    .addAnswer('Entendido, servicio en Ibarreta. ¬øNecesitas atenci√≥n administrativa o soporte t√©cnico?', { delay: 500 })
    .addAnswer('1Ô∏è‚É£ Atenci√≥n Administrativa\n2Ô∏è‚É£ Servicio T√©cnico', { capture: true }, async (ctx, { gotoFlow, fallBack }) => {
        if (ctx.body.toUpperCase().includes('MENU')) {
            return gotoFlow(flowPrincipal);
        }

        if (ctx.body.includes('1') || ctx.body.toLowerCase().includes('administrativa') || ctx.body.includes('1Ô∏è‚É£')) {
            return gotoFlow(flowAtencionAdministrativa);
        }
        if (ctx.body.includes('2') || ctx.body.toLowerCase().includes('tecnico') || ctx.body.includes('2Ô∏è‚É£')) {
            return gotoFlow(flowServicioTecnico);
        }
        return fallBack('No entend√≠ tu respuesta. Por favor, elige una opci√≥n v√°lida (1 o 2, o los emojis 1Ô∏è‚É£, 2Ô∏è‚É£). Escribe *MENU* para volver al inicio.');
    });

// Flujo para "Servicio de Internet en Fontana"
const flowServicioFontana = addKeyword(['fontana', '1', '1Ô∏è‚É£'])
    .addAnswer('Perfecto, servicio en Fontana. ¬øNecesitas atenci√≥n administrativa o soporte t√©cnico?', { delay: 500 })
    .addAnswer('1Ô∏è‚É£ Atenci√≥n Administrativa\n2Ô∏è‚É£ Servicio T√©cnico', { capture: true }, async (ctx, { gotoFlow, fallBack }) => {
        if (ctx.body.toUpperCase().includes('MENU')) {
            return gotoFlow(flowPrincipal);
        }

        if (ctx.body.includes('1') || ctx.body.toLowerCase().includes('administrativa') || ctx.body.includes('1Ô∏è‚É£')) {
            return gotoFlow(flowAtencionAdministrativa);
        }
        if (ctx.body.includes('2') || ctx.body.toLowerCase().includes('tecnico') || ctx.body.includes('2Ô∏è‚É£')) {
            return gotoFlow(flowServicioTecnico);
        }
        return fallBack('No entend√≠ tu respuesta. Por favor, elige una opci√≥n v√°lida (1 o 2, o los emojis 1Ô∏è‚É£, 2Ô∏è‚É£). Escribe *MENU* para volver al inicio.');
    });


// ----------------------------------------------------
// FLUJO PRINCIPAL (Punto de entrada del bot)
// ----------------------------------------------------

const flowPrincipal = addKeyword(['hola', 'ole', 'alo', 'buenos dias', 'buenas tardes', 'buenas noches', 'menu', EVENTS.WELCOME])
    .addAnswer('¬°Hola! Soy el ChatBot Vanguard. ¬øEn qu√© zona necesitas ayuda con tu servicio de internet?', { delay: 500 })
    .addAnswer('Por favor, elige una opci√≥n:', { delay: 500 })
    .addAnswer('1Ô∏è‚É£ Servicio de Internet en Fontana\n2Ô∏è‚É£ Servicio de Internet en Ibarreta\n3Ô∏è‚É£ Otra Zona', { capture: true }, async (ctx, { gotoFlow, fallBack }) => {
        if (ctx.body.toUpperCase().includes('MENU')) {
            return gotoFlow(flowPrincipal);
        }

        if (ctx.body.includes('1') || ctx.body.toLowerCase().includes('fontana') || ctx.body.includes('1Ô∏è‚É£')) {
            return gotoFlow(flowServicioFontana);
        }
        if (ctx.body.includes('2') || ctx.body.toLowerCase().includes('ibarret') || ctx.body.includes('2Ô∏è‚É£')) {
            return gotoFlow(flowServicioIbarra);
        }
        if (ctx.body.includes('3') || ctx.body.toLowerCase().includes('otra') || ctx.body.includes('3Ô∏è‚É£')) {
            return gotoFlow(flowOtraZona);
        }
        return fallBack('No entend√≠ tu respuesta. Por favor, elige una opci√≥n v√°lida (1, 2 o 3, o los emojis 1Ô∏è‚É£, 2Ô∏è‚É£, 3Ô∏è‚É£). Escribe *MENU* para volver al inicio.');
    })
    .addAnswer(
        'Lo siento, no entend√≠ tu solicitud. Por favor, utiliza las opciones del men√∫ o escribe *MENU* para empezar de nuevo.',
        { delay: 1500 }
    );


// ----------------------------------------------------
// FUNCI√ìN PRINCIPAL DE INICIO DEL BOT
// ----------------------------------------------------
const main = async () => {
    const adapterDB = new MockAdapter();

    const adapterFlow = createFlow([
        flowLlamarPersona,
        flowConsultarPrecios,
        flowMediosPago,
        flowEntradaManualPago, // <-- A√ëADE ESTE NUEVO FLUJO AQU√ç
        flowInformarPago,
        flowConfirmarPago,
        flowServicioTecnico,
        flowAtencionAdministrativa,
        flowOtraZona,
        flowServicioIbarra,
        flowServicioFontana,
        flowOtrasConsultas,
        flowPrincipal
    ]);
    const adapterProvider = createProvider(BaileysProvider);

    createBot({
        flow: adapterFlow,
        provider: adapterProvider,
        database: adapterDB,
    });

    QRPortalWeb();
};

main();